\documentclass[a4paper,oneside]{article}
\usepackage[slovene]{babel}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage[usenames]{color}
\usepackage[reqno]{amsmath}
\usepackage{amssymb}
\usepackage{fancybox}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage[bookmarks, colorlinks=true, %
linkcolor=black, anchorcolor=black, citecolor=black, filecolor=black,%
menucolor=black, runcolor=black, urlcolor=black%
]{hyperref}
\hypersetup{pdftitle={Iskanje optimalnega splošnega kompozitnega sortirnega algoritma}}
\hypersetup{pdfauthor={Jure Slak}}
\hypersetup{pdfsubject={Raziskovalna naloga}}
\usepackage[
    paper=a4paper,
    top=2.5cm,
    bottom=2.5cm,
%    textheight=24cm,
    textwidth=15cm,
    ]{geometry}


\usepackage{amsthm}
{
\newtheorem{izrek}{Izrek}[section]
\newtheorem{lema}[izrek]{Lema}
\newtheorem{trditev}[izrek]{Trditev}
\newtheorem{posledica}[izrek]{Posledica}
{
\theoremstyle{definition}
\newtheorem{definicija}{Definicija}[section]
}
}


\def\R{\mathbb R}
\def\N{\mathbb N}
\def\Z{\mathbb Z}
\def\C{\mathbb C}
\def\Q{\mathbb Q}
\def\ali{\;|\;}
\mathchardef\mhyphen="2D

\usepackage{algorithm}
\usepackage{algpseudocode}

\algnewcommand\algorithmicto{\textbf{to}}
\algnewcommand\algorithmicswap{\textbf{swap}}
\algnewcommand\Swap[2]{\State \ensuremath{\algorithmicswap(#1,\ #2)}}
\algrenewtext{For}[3]%
{$\algorithmicfor\ #1 \gets #2\ \algorithmicto\ #3\ \algorithmicdo$}

\newenvironment{BNF}{
    \\
    \Sbox
    \minipage{12cm}
}{
    \endminipage
    \endSbox
    \minipage{\textwidth}
    \vspace*{5pt}
    \begin{center}
        \fcolorbox{white}{white}{
            \TheSbox
        }
    \end{center}
    \vspace*{5pt}
    \endminipage
}

\def\:{\,::=\,}
\def\&:{\,::=&\,}
\def\para{\ensuremath{\,|\,}}
\newcommand{\q}[1]{\text{``}#1\text{''}}
\newcommand{\ntm}[1]{\ensuremath{<\!\!\text{#1}\!\!>}}
\newcommand{\bnf}[2]{\ensuremath{\ntm{#1} \: #2}}
\newcommand{\abnf}[2]{\ensuremath{\ntm{#1} \&: #2}}

\pagestyle{fancy}

\title{Iskanje optimalnega splošnega kompozitnega sortirnega algoritma}
\author{Jure Slak}
\date{\today}

\begin{document}
\addto\captionsslovene {
\renewcommand\bibname{}
}
\renewcommand\refname{}

\lstset{language=c++, morekeywords={function, swap, to, conf_t}}

\thispagestyle{empty}

\begin{center}{\large
  Gimnazija Vič
  \vfill
  Jure Slak\\[2mm]
  {\bf Iskanje optimalnega splošnega kompozitnega sortirnega algoritma}\\[10mm]
  Raziskovalna naloga\\[1cm]
  Mentor: prof. Klemen Bajec \\[2mm]
  Mentor: Gašper Ažman, dipl. mat.}
  \vfill
  \vfill
  \large Ljubljana, 2011
\end{center}
\pagebreak

\thispagestyle{empty}
\tableofcontents
\pagebreak

\section{Uvod}

Sortiranje ali razvrščanje na splošno pomeni preurejanje dane množice objektov, na katerih
je definirana relacija linearne urejenosti, v vrstni red, določen s to relacijo.
Namen sortiranja je ponavadi olajšati kasnejše iskanje pripadnikov take urejene množice. Kot tako je
v vsesplošni uporabi in ima velik pomen. Objekti so sortirani v telefonskih imenikih,
davčnih registrih, stvarnih kazalih, knjižnicah, slovarjih, skladiščih in skoraj povsod tam,
kjer moramo shranjene predmete iskati in dosegati. Že majhne otroke učimo, da stvari spravljajo
``v red'' in tako z neke vrste sortiranjem prihajajo v stik daleč preden se naučijo kaj
aritmetike.

\subsection{Teoretični uvod}

%% refraziraj
%Sortiranje je torej pomembno in bistveno opravilo, še posebno v obdelavi podatkov. 
%Sortiranje je tudi idealen primer, na katerem prikažemo izredno raznolikost algoritmov,
%ki imajo vsi isti namen, od katerih so mnogi optimalni v nekem pomenu, in od katerih
%ima večina neko prednost pred ostalimi.

%% opis psevdokode
% pri psevdokodi bom uporabljal while zanke, for zanke, vejitve in klice funkcij,
% prireditvene stavke in osnovno matematiko. Za polja a[j] pomeni element polja na indeksu
% j, polja se začnejo z indeksom 0.

\subsubsection{Definicija algoritma}


\textbf{Algoritem} je končno zaporedje ukazov, ki, če jih ubogamo, opravijo neko nalogo.
Zanj velja:
\begin{itemize}
  \item \textbf{Ima podatke}. Množica podatkov je lahko tudi prazna.
  \item \textbf{Vrne rezultat}. Vrne vsaj eno izračunano vrednost ali kaj stori, kot na primer
    premakne papir na tiskalniku na novo stran.
  \item \textbf{Je natančno določen}. Vsak ukaz mora nedvoumno povedati kaj storiti.
  \item \textbf{Se vedno konča}. Končati se mora pri vseh možnih naborih vhodnih podatkov.
  \item \textbf{Mogoče ga je opraviti}. V načelu ga je mogoče izpeljati ``peš'', s papirjem in
    svinčnikom.
\end{itemize}
% citat [KOZ86], str 11


\begin{definicija}
  Algoritem je \textbf{kompoziten} oziroma \textbf{sestavljen}, če je sestavljen iz večih
  drugih algoritmov.
\end{definicija}


\subsubsection{Definicija sortiranja}
Naj bo dan končen vektor elementov $\vec{a} = \left(a_1, a_2, \ldots a_n \right)$ in relacija $\leq$.
Naj bo $f(a)$ \emph{ključ} elementa. Definirana mora biti relacija linearne urejenosti med 
ključi elementov.V splošnem je dana relacija $\leq$ med elementi $\vec{a}$-ja, ki je definirana kot 
\[a_i \leq a_j \overset{def}{\Longleftrightarrow} f(a_i) \leq f(a_j). \]

$f$ je ponavadi trivialen, ker je $f(a)$ ponavadi kar del $\vec{a}$-ja in nam ga ni treba
računati, lahko pa to ni res. 

Definirajmo še tip \emph{item}, ki naj ponazarja elemente $\vec{a}$-ja. Naj bo \emph{key}
ključ elementa tipa \emph{cmp\_t}, na katerem je definirana relacija linearne urejenosti.

\begin{lstlisting}
struct item {
    cmp_t key;
    /* ostale komponente */
};
\end{lstlisting}

Ostale komponente predstavljajo s stališča urejanja nepomembne podatke o elementih v zbirki
S stališča sortirnih algoritmov je ključ \emph{edini} pomemben podatek in torej ni treba
podrobno definirati drugih komponent.

\begin{definicija}
  \textbf{Sortirni algoritem} je algoritem, ki prejme neko podatkovno strukturo s podatki
  in jih uredi po nekem vrstnem redu.
\end{definicija}

\begin{definicija}
  Sortirnemu algoritmu pravimo, da je \textbf{stabilna}, če ostane po končanem sortiranju
  relativni vrsti red elementov z istim ključem nespremenjen.
  Stabilnost sortiranja je pogosto zaželena, če so elementi že urejeni po neki
  sekundarni $\leq$ relaciji, torej glede lastnosti, ki jih (primarni) ključ ne izraža.
\end{definicija}

\begin{definicija}
  O neki sortirni metodi pravimo, da se dogaja \textbf{na mestu}, če se med izvajanjem podatki, ki
  jih sortiramo, ne kopirajo v dodaten pomnilnik.
\end{definicija}

\begin{definicija}
  Sortirni algoritem je \textbf{primerjalen}, če ureja elemente tako, da jih primerja med seboj.
\end{definicija}


Vsi nadaljnji algoritmi bodo definirani kot procedure s tremi parametri, $a$, $prvi$,
$zadnji$, ki predstavljajo:
\begin{itemize}
  \item $a$: polje, ki ga sortiramo. V splošnem zahtevamo, da je to katerakoli podatkovna
    struktura, ki $a$ podpira neko vrsto naključnega dostopa. Le-tega uporabljamo, kadar 
    uporabljamo operator $[\cdot]$. Zaradi časovne analize algoritmov zahtevamo, da operator 
    $[\cdot]$ deluje v konstantnem času. Indeksiranje elementov polja se začne z 0.
    V nadaljnjem opisovanju bom uporabljal besedo
    polje za katerokoli podatkovno strukturo, ki ustreza zgornjim zahtevam.
  \item $prvi$: indeks prvega elementa, ki ga želimo sortirati.
  \item $zadnji$: indeks elementa, ki je za zadnjim elementom, ki ga sortiramo. Lahko ni
    veljaven indeks v $a$.
\end{itemize}
Vse procedure bodo spremenile polje $a$, nobena ne bo ničesar vrnila.

Pri definiciji časovne in prostorske zahtevnosti algoritma bo za prostorsko zahtevnost 
navedena zgolj dodatna poraba pomnilnika, saj vsi algoritmi porabijo $O(n)$ pomnilnika za
shranjevanje celotnega polja, kjer $n$ predstavlja število elementov v polju, ali razliko
$zadnji - prvi$. 

\subsubsection{Urejanje z navadnim vstavljanjem}
\label{chapter:insertionsort}
Urejanje z navadnim vstavljanjem (\emph{angl.} insertion sort) je metoda,
podobna tisti, ki jo na široko uporabljajo igralci kart. Je primerjalni sortirni algoritem.

Zaporedje $a_1, a_2, \ldots, a_n$ razdelimo na že urejeni del $a_1, a_2, \ldots, a_{i-1}$
in še neurejeni del $a_i, \ldots a_n$. Nato $a_i$ vstavimo na pravo mesto v že sortirani
del. Ponovimo z $i + 1$. Začnemo z $i = 2$, ko je prvi del trivialno sortiran, saj ima le
en element.

Elemente miselno razdelimo na končno zaporedje $a_0, a_1, \ldots,
a_{i-1}$ in na začetno zaporedje $a_i,\ldots, a_n$. Na vsakem koraku začenši z $i = 1$ in
prirastkom ena, vstavimo $i$-ti element začetnega zaporedja na ustrezno mesto v končnem
zaporedju.

\begin{figure}[h]
    \begin{center}
        \includegraphics[height=45mm]{slike/insertionsort.png}
    \end{center}
    \vspace{-0.7cm}
    \caption{Grafična predstavitev urejanja z navadnim vstavljanjem.}
    \label{fig:insertionsortimage}
\end{figure}

Postopek sortiranja z navadnim vstavljanjem je prikazan na primeru osmih naključno
izbranih števil (glej sliko \ref{fig:insertionsortimage}). Algoritem navadnega
vstavljanja lahko zapišemo v psevdokodi nekako tako (sortira se vse na intervalu
$\left[prvi, zadnji\right)$):

\begin{algorithm}
  \caption{Insertion sort}\label{algo:insertionsort}
  \begin{algorithmic}[1]
    \Function{insertionsort}{a, prvi, zadnji}
        \For{i}{prvi + 1}{zadnji}
            \State $x \gets a[i]$
            \State $j \gets i - 1$
            \While{$x < a[j] \wedge j \geq 0$}
                \State $a[j+1] \gets a[j]$
                \State $j \gets j - 1$
            \EndWhile
            \State $a[j+1] = x$
        \EndFor
    \EndFunction
  \end{algorithmic}
\end{algorithm}

Med postopkom iskanja pravega mesta je dobro sproti premikati elemente med izvajanji
primerjanj. Z drugimi besedami, pustiti $x$, da se ``pogrezne'' tako, da $x$
primerjamo z naslednjim elementom $a_j$ in ga bodisi vstavimo, če je ključ $a_j$ manjši
ali enak $x$ ali pa $a_j$ premaknemo na desno ter nadaljujemo proti levi, če še nismo pri
levem robu polja. Postopek ``pogrezanja'' lahko ustavita ta dva ločena
pogoja, kot je prikazano v zgornji \emph{while} zanki.  Ko vstavimo še zadnji element v že 
urejeno zaporedje, smo z urejanjem zaključili.\\

\textbf{Časovna in prostorska zahtevnost}. \\
Časovna zahtevnost je v 
\begin{itemize}
  \item najboljšem primeru $O(n)$
  \item povprečnem primeru $O(n^2)$
  \item najslabšem primeru $O(n^2)$
\end{itemize}

Prostorska zahtevnost je v vsakem primeru $O(1)$, saj se vse premene dogajajo na
mestu.\newline

Spodnja časovna meja ustreza primeru, ko so elementi na začetku že urejeni, zgornja pa primeru,
ko so elementi na začetku nasprotno urejeni. Podani algoritem opisuje tudi stabilen postopek sortiranja, kajti medsebojni
vrstni red elementov z enakimi ključi ostane nespremenjen.

Urejanje z navadnim vstavljanjem je zelo učinkovito na majhnih poljih. Učinkovito je tudi na že
skoraj sortiranih poljih, saj se s tem približujemo obnašanju v najboljšem primeru.
Zaradi kvadratne časovne zahtevnosti je urejanje z navadnim vstavljanjem zelo neučinkovito na
dolgih poljih, če ta niso že skoraj urejena.

\subsubsection{Urejanje z izbiranjem}
\label{chapter:selectionsort}
Urejanje z izbiranjem (\emph{angl.} selection sort) je eden najenostavnejših primerjalnih sortirnih
algoritmov.

Algoritem deluje tako:
\begin{enumerate}
  \item najdi element z najmanjšim ključem
  \item zamenjaj ga z prvim elementom
  \item ponovi zgornja koraka za ostanek polja
\end{enumerate}

Polje je med sortiranjem razdeljeno na dva dela: podpolje že urejenih elementov, ki se
nahaja na začetku in podpolje elementov, ki jih je še potrebno sortirati in zasedajo
preostali del polja.
Postopek urejanja z izbiranjem je prikazan na sliki \ref{fig:selectionsortimage}.

\begin{figure}[h]
    \begin{center}
        \includegraphics[height=40mm]{slike/selectionsort.png}
    \end{center}
    \vspace{-0.7cm}
    \caption{Grafična predstavitev urejanja z navadnim vstavljanjem.}
    \label{fig:selectionsortimage}
\end{figure}

V psevdokodi bi zapisali urejanje z izbiranjem tako (sortira vse na intervalu
$\left[prvi, zadnji\right]$):


\begin{algorithm}
  \caption{Selection sort}\label{algo:selectionsort}
  \begin{algorithmic}[1]
    \Function{selectionsort}{a, prvi, zadnji}
        \For{i}{prvi}{zadnji}
            \State $x \gets i$
            \For{j}{i + 1}{zadnji}
                \If{$a[j] < a[x]$}
                    \State $x \gets j$
                \EndIf
            \EndFor
            \Swap{a[x]}{a[i]}
        \EndFor
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\textbf{Časovna in prostorska zahtevnost}. \\
Časovna zahtevnost je v 
\begin{itemize}
  \item najboljšem primeru $O(n^2)$
  \item povprečnem primeru $O(n^2)$
  \item najslabšem primeru $O(n^2)$
\end{itemize}

Prostorska zahtevnost je v najboljšem in povprečnem primeru $O(1)$, 
saj algoritem opravlja vse premene na mestu.

Ker ima urejanje z izbiranjem v vsakem primeru kvadratno časovno zahtevnost, je neprimerno
za daljša polja. Urejanje z izbiranjem tudi ni odvisno od prvotnega vrstnega reda,
saj mora za iskanje najmanjšega elementa vedno pregledati celoten ostanek polja.
Njegova prednost je v tem, da stori zelo malo zamenjav elementov, kar je še posebej
primerno takrat, ko je premikanje elementov drago (imamo velike elemente).

\subsubsection{Hitro urejanje}
\label{chapter:quicksort}
Hitro urejanje ali urejanje s porazdelitvami\footnote{vir: IJS-jev slovar računalniških izrazov
\url{http://www.ijs.si/cgi-bin/rac-slovar}}(\emph{angl.} quicksort) je eden izmed
najučinkovitejših sortirnih algoritmov, ki jih poznamo, razvil pa ga je C. A. R. Hoare.
Je primerjalni sortirni algoritem, ki uporablja metodo deli in vladaj.

Sortiranje s porazdelitvami temelji na dejstvu, da moramo premene opravljati na večje
razdalje, da bi bile najučinkovitejše. Recimo, da imamo $n$ nasprotno urejenih elementov.
V tem primeru jih lahko sortiramo z le $n/2$ premenami tako, da najprej premenjamo prvega
in zadnjega in se postopoma pomikamo proti sredini. Seveda je to možno le, če vemo, da so 
elementi natanko nasprotno urejeni.

Prejšnji primer nas napelje na naslednji algoritem: 
zberemo poljuben element (recimo mu pivot in ga označimo z $x$), nato začnemo 
polje pregledovati z leve, dokler ne najdemo elementa $a_i > x$ in nato z desne dokler ne 
najdemo elementa $a_i < x$. Elementa sedaj medsebojno zamenjamo in nadaljujemo s 
pregledovanjem in premenami, dokler se ne srečamo nekje na sredi polja.
Polje je sedaj razdeljeno na levi del s ključi manjšimi od $x$ in na desni del
s ključi večjimi od $x$. Metodo ponovimo na obeh delih dokler ne pridemo do že urejenih
podpolj. 

Iz prejšnjega algoritma ugotovimo, da je izbira pivota zelo
pomembna. Pogosto je, da za pivot vzamemo kar zadnji element, vendar to sproži ravno
najslabšo možnost izvajanja programa, če so elementi že urejeni. Zato sem v svoji
implementaciji za pivot vzel mediano prvega, srednjega in zadnjega elementa oziroma t.i.
mediano treh. Pogosta izbira je tudi naključni pivot. 

Postopek sortiranja s porazdelitvami je prikazan na primeru devetih naključno
izbranih števil (glej sliko \ref{fig:quicksortimage}). Izbrani pivoti so obarvani sivo.
Vsaka vrstica predstavlja svojo globino rekurzije.

%% definicija rekurzije ?kam, kje jo dobim? prevedi wikipedijo, ne navedi vira

\begin{figure}[h]
    \begin{center}
        \includegraphics[height=45mm]{slike/quicksort.jpg}
    \end{center}
    \vspace{-0.7cm}
    \caption{Grafična predstavitev urejanja s porazdelitvami.}
    \label{fig:quicksortimage}
\end{figure}

V psevdokodi bi zapisali algoritem urejanja s porazdelitvami
nekako tako (sortira se vse na intervalu
$\left[prvi, zadnji\right)$):
Predpostavimo, da obstaja funkcija \emph{swap}, ki zamenja vrednosti dveh spremenljivk.

\begin{algorithm}
  \caption{Quick sort}\label{algo:quicksort}
  \begin{algorithmic}[1]
    \Function{quciksort}{a, prvi, zadnji}
        \If{$zadnji - prvi < 2$} \Return \EndIf
        \State $s \gets first$
        \State $e \gets last - 1$
        \State $m \gets \lfloor(s+e)/2\rfloor$

        \If{$a[m] < a[s] < a[e] \vee a[e] < a[s] < a[m]$}
            \Swap{a[s]}{a[e]}
            \Comment{a[s] je mediana treh}
        \ElsIf{$a[e] < a[m] < a[s] \vee a[s] < a[m] < a[e]$}
            \Swap{a[m]}{a[e]}
            \Comment{a[m] je mediana treh}
        \EndIf

        \State $pivot \gets a[e]$
        \State $e \gets e - 1$

        \While{$s \leq e$}
            \While{$s \leq e \wedge a[s] < pivot$}
                \State $s \gets s + 1$
            \EndWhile
            \While{$s \leq e \wedge \neg(a[e] < pivot)$}
                \State $e \gets e - 1$
            \EndWhile
            \If{$s < e$}
                \Swap{a[s]}{a[m]}
            \EndIf
        \EndWhile
        \State $a[zadnji - 1] \gets a[s]$
        \State $a[s] \gets pivot$
        \State \textsc{quicksort}$(a, prvi, s)$
        \State \textsc{quicksort}$(a, s + 1, zadnji)$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\textbf{Časovna in prostorska zahtevnost}. \\
Časovna zahtevnost je v 
\begin{itemize}
  \item najboljšem primeru $O(n\log_2 n)$
  \item povprečnem primeru $O(n\log_2 n)$
  \item najslabšem primeru $O(n^2)$
\end{itemize}

Prostorska zahtevnost je v najboljšem in povprečnem primeru $O(\log_2 n)$, 
saj algoritem opravlja premene na mestu, vsak rekurziven klic pa zahteva $O(1)$ prostora.
V najslabšem primeru je rekurzivnih klicev $n$, zato zahteva algoritem $O(n)$ prostora.

Urejanje s porazdelitvami je eden najhitrejših sortirnih algoritmov, kar jih
poznamo. Svojo hitrost dolguje arhitekturi današnjih procesorjev, ki imajo
malo registrov in precej notranjega pomnilnika, saj lahko pivot ponavadi shranimo v
register, kar prihrani veliko poizvedb do pomnilnika. Dober je na enakomerno
porazdeljenih podatkih, a kljub pazljivemu izbiranju pivotov obstaja možnost neželenega
najslabšega primera, čeprav je zelo neverjetna. 

\subsubsection{Urejanje s kopico}
\label{chapter:heapsort}
Urejanje s kopico (\emph{angl.} heapsort) je sortirni algoritem,
ki si pri sortiranju pomaga s kopico.
\newline

Kopica je urejena drevesna podatkovna struktura.
Maksimalno kopico definiramo kot zaporedje ključev $h_i, h_{i+1}, \ldots, h_n$, pri čemer
velja
\begin{align*}
  h_i &\geq h_{2i} \\
  h_i &\geq h_{2i+1}
\end{align*}
pri vseh $i = 1 \ldots \lfloor n/2 \rfloor$. %% r sem zamenjal z n?? pa tudi tu je treba vzeti celi del n/2
Kopico lahko predstavimo v polju, kjer je koren kopice na mestu 1, in velja, da sta otroka
starša na mestu $i$, na mestih $2i$ in $2i + 1$.

Urejanje s kopico podatke najprej preuredi v maksimalno kopico. Nato odstrani koren kopice
-- največji element in ga zamenja z zadnjim elementom kopice. Potem ponovno ustvari
maksimalno kopico na preostanku elementov in zopet odstrani korenski element ter ga
zamenja s tistim na predzadnjem mestu. To se ponavlja dokler ni kopica dolga le en
element. 

Urejanje s kopico je prikazano na sliki \ref{fig:heapsortimage}.
Vsaka črta predstavlja svoj element, večji ko je element, temnejša je črta.
Do rdečega zaznamka na dnu slike poteka urejanje podatkov v kopico, nato pa odstranjevanje
največjega elementa in ponovna vzpostavitev kopice vse ko konca.
\begin{figure}[h]
    \begin{center}
        \includegraphics[height=45mm]{slike/Heap.png}
    \end{center}
    \vspace{-0.7cm}
    \caption{Grafična predstavitev urejanja s kopico.}
    \label{fig:heapsortimage}
\end{figure}


V psevdokodi bi algoritem urejanja s kopico izgledal nekako tako (sortira se vse na intervalu
$\left[prvi, zadnji\right)$):
Predpostavimo, da obstaja funkcija \emph{swap}, ki zamenja vrednosti dveh spremenljivk.

\begin{algorithm}
  \caption{Heap sort}\label{algo:heapsort}
  \begin{algorithmic}[1]
    \Function{heapsort}{a, prvi, zadnji}
        \State \textsc{nakopiči}$(a, prvi, zadnji)$
        \While{$prvi < zadnji$}
            \Swap{a[prvi]}{a[zadnji]};
            \State $zadnji \gets zadnji - 1$
            \State \textsc{pogrezni}$(a, prvi, prvi, zadnji)$
        \EndWhile
    \EndFunction
  \end{algorithmic}

  \begin{algorithmic}[1]
    \Function{nakopiči}{a, prvi, zadnji}
        \State $zacetek \gets \lfloor(prvi + zadnji) / 2\rfloor - 1$
        \While{$zacetek \geq prvi$} \Comment{Pogreznemo vse elemente, ki imajo otroke}
            \State \textsc{pogrezni}$(a, prvi, zacetek, zadnji)$
            \State $zadnji \gets zadnji - 1$
        \EndWhile
    \EndFunction
  \end{algorithmic}

  \begin{algorithmic}[1]
    \Function{pogrezni}{a, prvi, koren, zadnji}
        \State $odmik \gets koren - prvi$
        \While{$koren + odmik < zadnji$} \Comment{Dokler ima koren vsaj enega otroka}
            \State $otrok \gets koren + odmik + 1$
            \State $zamenjava \gets koren$ \Comment{Zapomnimo si, s čim je potrebno
            zamenjati koren}
            \If{$a[koren] < a[otrok]$} \Comment{Če je otrok večji od korena}
            \State $zamenjava = otrok$\Comment{Potem moramo zamenjati prvega otroka}
            \EndIf \Comment{Če drugi otrok obstaja in je večji od trenutne zamenjave}
            \If{$otrok + 1 \leq zadnji \wedge zamenjava < a[otrok + 1]$}
                \State $zamenjava = otrok + 1$\Comment{Potem zamenjamo njega}
            \EndIf
            \If{$zamenjava \neq koren$}
                \Swap{a[zam]}{a[koren]}
                \State $koren \gets zamenjava$
            \Else \Return 
            \State $odmik \gets koren - prvi$
            \EndIf
        \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\textbf{Časovna in prostorska zahtevnost}. \\
Časovna zahtevnost je v najboljšem, povprečnem in najslabšem primeru $O(n\log_2 n)$.

Prostorska zahtevnost je v vsakem primeru $O(1)$, saj je kopica predstavljena kar v
seznamu, ki ga urejamo, in ker se vse premene dogajajo na mestu.

Čas izvajanja urejanja s kopico je neodvisen od morebitne urejenosti podatkov v polju,
kot lahko razberemo iz časovne zahtevnosti. Zaradi dokaj zapletenega postopka sortiranja,
na manjših poljih ni tako uspešen, je pa čedalje bolj uspešen, ko se dolžina polja
povečuje.

\subsubsection{Urejanje z zlivanjem}
\label{chapter:mergesort}
Urejanje z zlivanjem (\emph{angl.} merge sort) je primerjalni sortirni algoritem, ki
uporablja metodo deli in vladaj. Odkril ga je John von Neumann leta 1945.
Urejanje z zlivanjem uporablja idejo, da je v sortirano polje hitreje združiti dve že
sortirani polji, kot pa dve še ne sortirani. 
Algoritem urejanja z zlivanjem ureja tako:
\begin{enumerate}
  \item Če je polje dolgo 0 ali 1 je že sortirano, če ne:
  \item Razdeli polje v dve približno enako dolgi podpolji
  \item Sortiraj podpolji 
  \item Združi podpolji nazaj v celotno sortirano polje.
\end{enumerate}

Algoritem je grafično prikazan na sliki \ref{fig:mergesortimage} na primeru sedmih
naključno izbranih števil.
Vsaka vrstica števil predstavlja svojo globino rekurzije, vse dokler niso polja dolga le
po en element. Nato se začne izvajati četrta točka algoritma, ponazorjena z vrsticami
nižje od črtkane črte, ki združi podpolja v sortirano polje.

\begin{figure}[h]
    \begin{center}
        \includegraphics[height=55mm]{slike/merge_sort.png}
    \end{center}
    \vspace{-0.7cm}
    \caption{Grafična predstavitev urejanja z zlivanjem.}
    \label{fig:mergesortimage}
\end{figure}

V psevdokodi bi ta algoritem zapisali nekako tako (sortira se vse na intervalu
$\left[prvi, zadnji\right)$):

\begin{algorithm}
  \caption{Merge sort}\label{algo:mergesort}
  \begin{algorithmic}[1]
    \Function{mergesort}{a, prvi, zadnji}
        \If{$zadnji - prvi < 2$} \Return \EndIf
        \State $srednji \gets \lfloor(prvi + zadnji) / 2\rfloor$
        \textsc{mergesort}$(a, prvi, srednji)$
        \textsc{mergesort}$(a, srednji + 1, zadnji)$
        \textsc{merge}$(a, prvi, srednji, zadnji)$
    \EndFunction
  \end{algorithmic}
  
  \begin{algorithmic}[1]
    \Function{merge}{a, prvi, srednji, zadnji}
        \State $i \gets prvi$
        \State $j \gets srednji$
        \State $rezultat = []$ \Comment{Naredimo prazno polje rezultat}
        \While{$i < srednji \wedge j < zadnji$}
            \If{$a[i] < a[j]$}
                \State $rezultat.append(a[i])$ \Comment{Dodamo a[i] v polje rezultat}
                \State $i \gets i + 1$
            \Else
                \State $rezultat.append(a[j])$ \Comment{Dodamo a[j] v polje rezultat}
                \State $j \gets j + 1$
            \EndIf
        \EndWhile
        \While{$i < srednji$}
            \State $rezultat.append(a[i])$ \Comment{Dodamo a[i] v polje rezultat}
        \EndWhile
        \While{$j < srednjj$}
            \State $rezultat.append(a[j])$ \Comment{Dodamo a[j] v polje rezultat}
        \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\textbf{Časovna in prostorska zahtevnost}. \\
Časovna zahtevnost je v najboljšem, povprečnem in najslabšem primeru $O(n\log_2 n)$.

Prostorska zahtevnost je v vsakem primeru $O(n)$. % ker O(n + log n)

Časovna zahtevnost urejanja z zlivanjem ni odvisna od morebitne že delne urejenosti ali
neurejenosti podatkov v polju. V praksi je urejanje z zlivanjem najbolj učinkovito na
sekvenčnih medijih kot na primer tračnih enotah ali podatkovnih strukturah, ki nimajo hitrega
neposrednega dostopa do nekega elementa z njegovim indeksom, kot na primer povezani seznami.


\subsection{Nameni in cilji}
\subsection{Hipoteze}
\begin{enumerate}
  \item Kompoziten algoritem se odnese boljše na različnih tipih podatkov kot vsak
    posamezen algoritem.
\end{enumerate}
\section{Metode dela}
Za preverjanje hipotez(e) sem si izbral eksperiment, saj se mi zdi da je to edina metoda
dela, s katero je hipotezo sploh mogoče preverjati in pa delo z viri, ki sem jih
potreboval pri pripravi eksperimenta.
Za izvedbo eksperimenta sem implementiral vse v teoretičnem delu opisane sortirne
algoritme. Za implementacijo sem si izbral programski jezik C++, predvsem zaradi njegove
hitrosti in še česa. Ker se program prevede v strojno kodo in je zato najhitrejši možen. %% hja česa?

\subsection{Implementacija sortirnih algoritmov}
Vsak izmed sortirnih algoritmov je implementiran kot funkcija z dvema parametorma.
Vsaka funkcija sprejme dva Random Access iteratorja, %% iteratorja z naključnim dostopom
ki kažeta na prvi element, ki ga sortiramo in na prvi element za tistim, ki ga sortiramo
zadnjega. Slednji je lahko neveljaven v polju (kaže preko njenega konca).
Tako obliko funkcij sem si izbral predvsem zato, ker je v sladu z zapisom, ki ga uporablja
C++-ova knjižnica \emph{algortihm}. Drugi razlog je, da s tem zapisom dosežemo minimalno število
parametrov pri trenutni funkcionalnosti. Če bi želeli le en parameter, bi bilo to
izvedljivo, vendar bi se morali odpovedati zmožnosti, da lahko sedaj sortiramo le željeni
del polja. V primeru zgolj enega parametra to ne bi bilo možno, vedno bi se
sortiralo celotno polje.

Vsak sortirni algoritem, ki sem ga implementiral, sortira zgolj s uporabo operatorja $<$
(``je manjše''), ki se obnaša enako kot operator linearne urejenosti $\leq$. Vsak
algoritem je definiran kot funkcija tipa \emph{void}, kar pomeni da ne vrne ničesar in
torej spremeni vrstni red elementov polja, ki ji ga podamo.

\subsection{Implementacija kompozitnega sortirnega algoritma}
\label{chapter:tweaksort}
Ker so sortirni algoritmi vsak zase dobri na zgolj nekaterih dolžinah polj in se pri tej
lastnosti razlikujejo, nas to privede do zamisli, da bi pri dani dolžini $n$ uporabili tisti
sortirni algoritem, ki je pri tem $n$ najboljši. Torej moramo vedeti pri katerem $n$ je
potrebno uporabiti kateri sortirni algoritem, kar pa si bomo morali nekam zapomniti. Za ta
namen sem definiral tip $conf\_t$, v katerem je shranjena konfiguracija kompozitnega
sortirnega algoritma. 

Konfiguracija pove kateri sortirni algoritem naj se uporablja pri
katerem $n$. Konfiguracijo se lahko predstavi kot niz znakov z zelo preprostimi
pravili. Tolmač konfiguracije iz niza znakov v conf\_t dopušča bolj ohlapna pravila, kot so
definirana v slovnici. Slovnica konfiguracije v notaciji
BNF\footnote{http://www.cui.unige.ch/db-research/Enseignement/analyseinfo/AboutBNF.html}
je definirana sledeče:
\\
\begin{BNF} %% zakaj maš ti kle ~BNF
  \begin{align*}
    \abnf{sort}{\q{i} \ali \q{s} \ali \q{q} \ali \q{h} \ali \q{m}}\\ %% presledki me matrajo
    \abnf{stevilo}{\in \N \ali \q{-1}} \\
    \abnf{token}{\q{:}\ntm{sort}\q{\mbox{--}~\mbox{--}\mbox{$>$}}\ntm{stevilo}}\\
    \abnf{konfiguracija}{\ntm{token} \ali \ntm{konfiguracija}\ntm{token}}
  \end{align*}
\end{BNF}

Kompozitni sortirni algoritem torej vedno uporabi tisti sortirni algoritem, ki je zapisan
v konfiguraciji za trenutni $n$. Tako spremenjen algoritem za urejanje, bi torej vhodno
polje vedno uredil s čimbolj optimalnim sortirnim algoritmom (če je bilo tako seveda
zapisano v konfiguraciji). Vendar imajo nekateri algoritmi za urejanje zaradi metode deli in vladaj,
ki jo uporabljajo pri urejanju, še to lepo lastnost, da polja delijo na manjša polja. Za
ta manjša polja pa lahko spet pogledamo v konfiguracijo, kateri sortirni algoritem je
najbolj zaželen in podpolje uredimo z le-tem. To nam prinese možnost veliko hitrejšega
urejanja polj, saj se lahko odločimo kateri sortirni algoritem bomo
uporabili, ne le za vhodno polje, temveč tudi za nekatera podpolja, ki jih ustvarijo
sortirni algoritmi kot na primer hitro urejanje ali urejanje z zlivanjem.

Kompozitni sortirni algoritem mora torej pri svoji implementaciji poleg dve RAI-jev
sprejeti tudi konfiguracijo. Proceduro \emph{sort}, ki predstavlja kompozitni sortirni
algoritem sem definiral sledeče: 
\begin{lstlisting}
  void sort(RAI firts, RAI last, const conf_t\amp conf);
\end{lstlisting}

% more to be written
%


\section{Rezultati}
\section{Ugotovitve in razprava}
\section{Sklep}
Potrdili smo hipotezo. Lahko bi izboljšali z bolj optimizirano implementacijo.
\section{Zaključek}
Zadeva je uporabna.
\section{Viri in Literatura}
\subsection{Literatura}
\vspace{-1cm}
\begin{thebibliography}{99}
  \bibitem[KOZ86]{bib:koz86} {J. Kozak, \emph{Podatkovne strukture in algoritmi}. DMFA SRS, Ljubljana 1986. }
\end{thebibliography}
\subsection{Priloge}


\end{document}
% vim: spell spelllang=sl
